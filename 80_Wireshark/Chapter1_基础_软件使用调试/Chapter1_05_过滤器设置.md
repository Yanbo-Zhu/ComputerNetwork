
# 1 Wireshark过滤器设置

初学者使用wireshark时，将会得到大量的冗余数据包列表，以至于很难找到自己自己抓取的数据包部分。wireshar工具中自带了两种类型的过滤器，学会使用这两种过滤器会帮助我们在大量的数据中迅速找到我们需要的信息。
捕获过滤器看作是一级过滤，显示过滤看做二级过滤: 也就是说：先规定一下数据报的特征（一级过滤），由于需求过滤完之后还是满足不了要求所以再进行一次过滤（二级过滤），笔者只是打个比方，可能不太严谨。

可以看出这两种过滤器在使用和功能上有着区别：
捕捉过滤器是数据经过的第一层过滤器，它用于控制捕捉数据的数量，以避免产生过大的日志文件。而显示过滤器是在对捕获结果进行筛选时使用，允许我们在日志文件中迅速准确地找到所需要的记录。
捕捉过滤器必须在捕捉数据包之前设置，若是捕捉的数据包不是我们想要的，需要重新设置捕捉过滤器并重新捕捉数据包。显示过滤器的功能比捕捉过滤器更为强大，可以重复设置表达式对捕获的结果重复筛选而不需要重新捕获数据包。


## 1.1 捕捉过滤器 (CaptureFilters)

使用的是 BPF语法: Berkeley Packet Filter , 基于 Libpcap/wincap 库

捕获过滤器表达式作用在wireshark开始捕获数据包之前，只捕获符合条件的数据包，不记录不符合条件的数据包。
捕获过滤器表达式没有像显示过滤器表达式那样明显的规律，但写法不多所以也不难；而且除非全部捕获要占用的磁盘空间实现太大，且你非常明确过滤掉的数据包是你不需要的，不然一般都不用捕获过滤器表达式而用显示过滤器表达式。

捕获过滤器的菜单栏路径为Capture --> Capture Filters。用于**在抓取数据包前设置。**
**![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216161942199-694292737.png)**

 如何使用？可以在抓取数据包前设置如下。
![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216162715878-976869768.png)

ip host 60.207.246.216 and icmp表示只捕获主机IP为60.207.246.216的ICMP数据包。获取结果如下：
![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216162922295-1140020404.png)

### 1.1.1 语法


1 Protocol（协议）
可能的值: ether, fddi, ip, arp, rarp, decnet, tcp and udp等。如果没有特别指明是什么协议，则默认使用所有支持的协议

2 Direction（方向）
可能的值: src, dst, src and dst, src or dst。如果没有特别指明来源或目的地，则默认使用 “src or dst” 作为关键字
比如：”host 10.2.2.2″与”src or dst host 10.2.2.2″是一样的

3 Host(s)
可能的值： net, port, host, portrange。如果没有指定此值，则默认使用”host”关键字
比如："src 10.1.1.1"与”src host 10.1.1.1″相同

4 Logical Operations（逻辑运算）
可能的值：not, and, or
否(“not”)具有最高的优先级。或(“or”)和与(“and”)具有相同的优先级，运算时从左至右进行。
例如，
“not tcp port 3128 and tcp port 23"与”(not tcp port 3128) and tcp port 23"相同。
"not tcp port 3128 and tcp port 23"与"not (tcp port 3128 and tcp port 23)"不同。


### 1.1.2 实例  


#### 1.1.2.1 协议过滤  

比较简单，直接在抓包过滤框中直接输入协议名即可。
TCP，只显示TCP协议的数据包列表
HTTP，只查看HTTP协议的数据包列表
ICMP，只显示ICMP协议的数据包列表

#### 1.1.2.2 IP过滤
显示来源IP地址为10.1.1.1的封包: ip src host 10.1.1.1

host 192.168.1.104
src host 192.168.1.104
dst host 192.168.1.104

#### 1.1.2.3 端口过滤

port 80
src port 80
dst port 80
显示目的TCP端口为3128的封包: tcp dst port 3128

#### 1.1.2.4 逻辑运算符&&, || , !

src host 192.168.1.104 && dst port 80 抓取主机地址为192.168.1.80、目的端口为80的数据包
host 192.168.1.104 || host 192.168.1.102 抓取主机为192.168.1.104或者192.168.1.102的数据包
！broadcast 不抓取广播数据包


#### 1.1.2.5 其他例子
显示目的或来源IP地址为10.1.2.3的封包: host 10.1.2.3
显示来源为UDP或TCP，并且端口号在2000至2500范围内的封包: src portrange 2000-2500
显示除了icmp以外的所有封包: not icmp
显示来源IP地址为10.7.2.12，但目的地不是10.200.0.0/16的封包: src host 10.7.2.12 and not dst net 10.200.0.0/16
显示源IP为10.4.1.12或源网络为10.6.0.0/16，目的TCP 端口号在200至10000之间，并且目的位于网络 10.0.0.0/8内所有封包 : (src host 10.4.1.12 or scr net 10.6.0.0/16) and tcp dst portrange 200-10000 and dst net 10.0.0.0/8
捕获广播流量: broadcast


## 1.2 显示过滤器 (DisplayFilters)

  显示过滤器是用于在抓取数据包后设置过滤条件进行过滤数据包。通常是在抓取数据包时设置条件相对宽泛，抓取的数据包内容较多时使用显示过滤器设置条件顾虑以方便分析。同样上述场景，在捕获时未设置捕获规则直接通过网卡进行抓取所有数据包，如下

![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216163301344-1400128534.png)

执行ping www.huawei.com获取的数据包列表如下

![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216163359260-101806867.png)

观察上述获取的数据包列表，含有大量的无效数据。这时可以通过设置显示器过滤条件进行提取分析信息。ip.addr == 211.162.2.183 and icmp。并进行过滤。

![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216163607973-642074591.png)

  上述介绍了抓包过滤器和显示过滤器的基本使用方法。**在组网不复杂或者流量不大情况下，使用显示器过滤器进行抓包后处理就可以满足我们使用。**下面介绍一下两者间的语法以及它们的区别。


### 1.2.1 语法

![在这里插入图片描述](https://img-blog.csdnimg.cn/882e894882294c1c926d234b574df3b2.png)

-   Protocol(协议)  
    位于OSI模型第2至7层的协议，如：IP、TCP、DNS等
    
-   String1,String2（可选项）  
    协议的子类
    
-   Comparison Operator（比较运算符）  
    可以使用6种比较运算符  
    ![在这里插入图片描述](https://img-blog.csdnimg.cn/6eb3ce071b5e435281bffc98b34a1e3d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546E54G16aOO,size_12,color_FFFFFF,t_70,g_se,x_16)
- Logical Operations（逻辑运算符）
    - ![在这里插入图片描述](https://img-blog.csdnimg.cn/b8199c77923846f3939f7f3663679af7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546E54G16aOO,size_12,color_FFFFFF,t_70,g_se,x_16)
    - 逻辑异或是一种排除性的或。当其被用在过滤器的两个条件之间时，只有当且仅当其中的一个条件满足时，这样的结果才会被显示在屏幕上
    - 例如：“tcp.dstport 80 xor tcp.dstport 1025” : 只有当目的TCP端口为80或者来源于端口1025（但又不能同时满足这两点）时，这样的数据包才会被显示

### 1.2.2 实例

#### 1.2.2.1 比较操作符

比较操作符有== 等于、！= 不等于、> 大于、< 小于、>= 大于等于、<=小于等于。
  
#### 1.2.2.2 逻辑运算符为 and/or/not /xor

xor: 有且仅有一个条件被满足
not: 没有条件被满足

过滤多个条件组合时，使用and/or。比如获取IP地址为192.168.1.104的ICMP数据包表达式为ip.addr == 192.168.1.104 and icmp
  
#### 1.2.2.3 ip过滤

ip.src ==192.168.1.104 显示源地址为192.168.1.104的数据包列表
ip.dst==192.168.1.104, 显示目标地址为192.168.1.104的数据包列表
ip.addr == 192.168.1.104 显示源IP地址或目标IP地址为192.168.1.104的数据包列表
![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216091553689-1436668121.png)


2
显示来源或目的IP地址为10.1.1.1的封包
ip.addr == 10.1.1.1

3
显示来源不为10.1.2.3或目的不为10.4.5.6的包
ip.src != 10.1.2.3 or ip.dst != 10.4.5.6

#### 1.2.2.4 端口过滤

tcp.port ==80,  显示源主机或者目的主机端口为80的数据包列表。
tcp.srcport == 80,  只显示TCP协议的源主机端口为80的数据包列表。
tcp.dstport == 80，只显示TCP协议的目的主机端口为80的数据包列表。

![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216092151712-331226826.png)

显示来源或目的TCP端口号为25的封包
tcp.port == 25

显示目的TCP端口号为25的封包
tcp.dstport == 25


文本管理流量（telnet或ftp）
tcp.port == 23 || tcp.port == 21

#### 1.2.2.5 协议过滤

比较简单，直接在Filter框中直接输入协议名即可。**注意：协议名称需要输入小写。**
arp, ip, icmp. udp, tcp, bootp, dns 

tcp，只显示TCP协议的数据包列表
http，只查看HTTP协议的数据包列表
icmp，只显示ICMP协议的数据包列表

![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216091233009-756441984.png)

显示SNMP或DNS或ICMP封包: snmp || dns || icmp

排除arp流量: !arp

#### 1.2.2.6 tcp.flags 过滤

6
显示包含TCP标志的封包
tcp.flags

7
显示包含TCP SYN标志的封包
tcp.flags.syn == 1

#### 1.2.2.7 Http模式过滤
http.request.method=="GET",   只显示HTTP GET方法的。

![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216092834478-225085029.png)

#### 1.2.2.8 按照数据包内容过滤
假设我要以IMCP层中的内容进行过滤，可以单击选中界面中的码流，在下方进行选中数据。如下

![](https://img2018.cnblogs.com/blog/774327/201906/774327-20190619074816611-772694481.png)

右键单击选中后出现如下界面

![](https://img2018.cnblogs.com/blog/774327/201906/774327-20190619074945293-3644404.png)

选中Select后在过滤器中显示如下

![](https://img2018.cnblogs.com/blog/774327/201906/774327-20190619075028529-409167.png)

后面条件表达式就需要自己填写。如下我想过滤出data数据包中包含"abcd"内容的数据流。**包含的关键词是contains 后面跟上内容。**

![](https://img2018.cnblogs.com/blog/774327/201906/774327-20190619075212180-801507805.png)


## 1.3 自建新的过滤器
将其保存, 然后作为快捷方式放在右边 

# 2 案例分析: Wireshark抓包分析TCP三次握手

1）TCP三次握手连接建立过程
Step1：客户端发送一个SYN=1，ACK=0标志的数据包给服务端，请求进行连接，这是第一次握手；
Step2：服务端收到请求并且允许连接的话，就会发送一个SYN=1，ACK=1标志的数据包给发送端，告诉它，可以通讯了，并且让客户端发送一个确认数据包，这是第二次握手；
Step3：服务端发送一个SYN=0，ACK=1的数据包给客户端端，告诉它连接已被确认，这就是第三次握手。TCP连接建立，开始通讯。

![](http://www.cr173.com/up/2013-5/2013050217125714223.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/5f248603a7f248a39b4fb0641abb1a4c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA546E54G16aOO,size_20,color_FFFFFF,t_70,g_se,x_16)

2）wireshark抓包获取访问指定服务端数据包
Step1：启动wireshark抓包，打开浏览器输入www.huawei.com。
Step2：使用ping www.huawei.com获取IP。
![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216104018866-329362658.png)
Step3：输入过滤条件获取待分析数据包列表 ip.addr == 211.162.2.183

![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216104535874-2007397893.png)

图中可以看到wireshark截获到了三次握手的三个数据包。第四个包才是HTTP的， 这说明HTTP的确是使用TCP建立连接的。

## 2.1 第一次握手数据包

客户端发送一个TCP，标志位为SYN，序列号Seq 为0， 代表客户端请求建立连接。 如下图。

![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216104744830-1050984889.png)

数据包的关键属性如下：

- Seq = 0 ：初始建立连接值为0，数据包的相对序列号从0开始，表示当前还没有发送数据
- 标志位的值 为 SYN
    - SYN =1 : 表示请求建立连接
    - Ack =0：初始建立连接值为0，已经收到包的数量，表示当前没有接收到数据

## 2.2 第二次握手的数据包

服务器发回确认包, 
标志位为 SYN,ACK. 
将确认序号(Acknowledgement Number)的值 设置为, 客户端的发来的请求包的的序列号(seq)加1, 即0+1=1

![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216104950687-1236457395.png)

 数据包的关键属性如下：
- Seq = 0 ：初始建立值为0，表示当前还没有发送数据
- `[SYN + ACK]`: 标志位的值，同意建立连接，并回送SYN+ACK
    - Syn = 1; 
    - Ack = 1：表示当前端成功接收的数据位数，虽然客户端没有发送任何有效数据，确认号还是被加1，因为包含SYN或FIN标志位。（并不会对有效数据的计数产生影响，因为含有SYN或FIN标志位的包并不携带有效数据）


## 2.3 第三次握手的数据包

客户端再次发送确认包(ACK) 给客户端
- seq 为 1, 因为 第一次握手的时候, seq = 0; 表示值前已经发送1个数据
- SYN标志位为0,
- ACK标志位为1. 表示已经收到记录
    - 值 为 服务器发来 包 的 seq的值+1

![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216105102440-1450961874.png)

## 2.4 之后的数据互换 
就这样通过了TCP三次握手，建立了连接。开始进行数据交互

![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216112117277-377988567.png)

## 2.5 下面针对数据交互过程的数据包进行一些说明：
1
Seq: 1
Ack: 1: 说明现在共收到1字节数据
![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216112320086-467982290.png)

2
Seq: 1  
Ack: 951: 说明现在服务端共收到951字节数据

![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216112705306-1390447949.png)


3 
在TCP层，有个FLAGS字段，这个字段有以下几个标识：SYN, FIN, ACK, PSH, RST, URG。如下
其中，对于我们日常的分析有用的就是前面的五个字段。它们的含义是：SYN表示建立连接，FIN表示关闭连接，ACK表示响应，PSH表示有DATA数据传输，RST表示连接重置。
![](https://img2018.cnblogs.com/blog/774327/201812/774327-20181216113119425-2072328757.png)


