

Distribute System 如果各个系统时间不同步 会出现问题的 
- Multiple processes should not simultaneously access a shared resource, e.g. printer à cooperate in granting each other temporary exclusive access
- Multiple processes need to agree on the ordering of events, e.g. message m1 from process P was sent before or after message m2 from process Q

Synchronization in Distributed Systems
Two approaches will be discussed:
- Synchronization based on actual time,
- Synchronization in which only relative ordering matters ->  no need for absolute time



# 1 Physical Time

Synchronizing algorithms: Two approaches
- global absolute time ->  actual clock time is important (e.g. real-time systems) ->  synchronize with real-world clocks
- global relative time


Clock Synchronization Algorithms
- Universal Coordinated Time (UTC)
- If one machine in the system has access to an UTC service, the goal becomes keeping all the other machines synchronized to it,
- If no machine has access to an UTC service, each machine keeps track of its own time à goal is to keep all the machines together as well as possible


## 1.1 Model of the System

- Each machine i has a local clock
- Hi(t): hardware clock value (by oscillator, discontinuous)
- $C_i(t)$: software clock value (generated by operating system)
    - $C_i(t)$ = r Hi(t) + A, a tick occurs every so many quartz oscillations!
    - t is the UTC time,
    - A ist off set, start_time 
    - Clock resolution: period between updates of $C_i(t)$ ->  limit on determining order of events
    - Perfect world: $C_i(t)$ = t for all i and all t,
- $C_i(t)$: approximation of the UTC - # nsec’s elapsed at time t since a reference time



# 2 Synchronization protocols

如何实现连个机器间的时间同步 ,  克服两个机器通讯的 latency 

![](image/Pasted%20image%2020241130224324.png)


Cristian's Algorithm
![](image/Pasted%20image%2020241130224406.png)


The Berkeley Algorithm
![](image/Pasted%20image%2020241130224452.png)












# 3 Network Time Protocol (NTP) 

- Time synchronization system for computer clocks through the Internet – most widely used,
- Enables clients to be accurately synchronized to UTC despite message delays … with (worldwide) accuracy of 1-50 ms,
- Internet standard protocol
    - Version 3 (RFC-1305), simple NTP version 4 (RFC-2030)
    - Application Layer (OSI-layer 7) using UDP (port 123)
    - Clients exist for almost all platforms (Windows, Linux, etc.)
- Provides mechanisms to
    - Synchronize clocks to some reference time
    - Coordinate time distribution in a large, diverse Internet


## 3.1 Basic Features

- Based on UTC (Universal Time Coordinated)
- Independent from time zones 
    - Several institutions contribute their estimate of the current time
- Fault-tolerant
    - Selects the best of several available time sources -> leverages heterogeneous accuracy in clocks
    - Multiple candidates can be combined to minimize the accumulated error
    - Detects and avoids insane time sources
    - Survives lengthy losses of connectivity
- Highly scalable
    - Reference clock sources, sub-nodes and clients form hierarchical graph
    - Each node can exchange time information either bidirectional or unidirectional

## 3.2 Clock Strata

层；[地质]地层；阶层

NTP uses a hierarchical system of time sources:
- Each level is termed a stratum and is assigned
- number starting with zero for the reference clock at the top,
- A server synchronized to a stratum n server runs at stratum n+1,
- The number represents the distance from the reference clock,
- Stratum is not always an indication of quality or reliability


![](image/Pasted%20image%2020241130225508.png)



- NTP client 和 NTP Server 之间如何同步时间 
    - NTP client will regularly poll one or more NTP servers
        - Exchange of several packet pairs (request, reply)
        - Containing originate resp. receive timestamp
    - To synchronize its clock, the client must compute its time offset and round-trip delay (travelling time)

![](image/Pasted%20image%2020241130230057.png)


This calculation uses the premise 前提，假设 that transport is symmetric (same delay in both directions) -> in principle the timeline must be an equilateral triangle
Many packet pairs and many sources are averaged over a long time ->  accuracy increases



## 3.3 NTP Operation: Server Selection

- Examine values from several peers (=servers) and look for relatively unreliable values,
- May switch the peer used primarily for sync,
- Peers with low stratum # are more favored
    - “closer” to primary time sources
- Also favored are peers with lowest dispersion 分布
- May modify local clock update frequency w.r.t. observed drift rate
- Accuracy:
    - ~ 10s of milliseconds over Internet paths
    - ~ 1 millisecond on LANs

![](image/Pasted%20image%2020241130230919.png)

## 3.4 Clock Synchronization: Take-away points

- Clocks on different systems will always behave differently
    - Disagreement between machines can result in undesirable behavior
- NTP clock synchronization
    - Rely on timestamps to estimate network delays
    - 100s 𝝁s−ms accuracy
    - Clocks never exactly synchronized
- Often inadequate for distributed systems
    - Often need to reason about the order of events
    - Might need precision on the order of ns


# 4 Logical clocks: Lamport Clocks



## 4.1 Logical Clocks


- For many purposes, ==it is sufficient that all machines agree on the same time; it does not need to be the real time,==
    - Internal consistency of the clocks matters,
    - E.g., for make tool it is sufficient to know whether input.c is older or newer than input.o
- Logical clocks proposed by Leslie Lamport in 1978
- Insight: only the events themselves matter

Basic idea:
- Disregard the precise clock time,
- Instead, capture just a “happens before” relationship between a pair of events

## 4.2 Defining “happens-before”

Consider three processes: P1, P2, and P3

Notation: Event a happens before event b (a ->  b)

- Can observe event order at a single process
    - If same process and a occurs before b, then a -> b
- Can observe ordering when processes communicate
    - If c is a message receipt of b, then b -> c
- Can observe ordering transitively
    - If a ->  b and b ->  c, then a -> c
- a, d not related by ->  so concurrent, written as a || d

![](image/Pasted%20image%2020241130232903.png)


# 5 The Lamport Clock algorithm

> 这个算法的作用是 将 不同 process 中的 若干个event , 每个都 tag 上 clock time  , 并且使用 这个event totally-ordered in time Horizont

- We seek a clock time C(a) for every event a on which all processes agree,
- Clock condition: If a ->  b, then C(a) < C(b)
- In addition: clock time, C, must always go forward!
- Corrections to time: adding a positive value
- Plan: tag events with clock times; use clock times to make distributed system correct

- Can totally-order events in a distributed system: that’s useful!
    - We saw an application of Lamport clocks for totally-ordered multicast
- But: while by construction, a ->  b implies C(a) < C(b),
    - The converse is not necessarily true:
        - C(a) < C(b) does not imply a ->  b (possibly, a || b)

We cannot use Lamport clock timestamps to infer causal relationships between events à see vector timestamps (Tanenbaum)

## 5.1 例子1

![](image/Pasted%20image%2020241130233348.png)

![](image/Pasted%20image%2020241130233355.png)


![](image/Pasted%20image%2020241130233406.png)

![](image/Pasted%20image%2020241130233431.png)


![](image/Pasted%20image%2020241130233502.png)


## 5.2 例子2

![](image/Pasted%20image%2020241130233558.png)


## 5.3 Lamport Timestamps: Ordering all events

clock time C(a) for  event a om processes i or j 

![](image/Pasted%20image%2020241130233838.png)


