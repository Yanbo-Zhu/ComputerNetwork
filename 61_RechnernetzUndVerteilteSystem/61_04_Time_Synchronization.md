

Distribute System å¦‚æœå„ä¸ªç³»ç»Ÿæ—¶é—´ä¸åŒæ­¥ ä¼šå‡ºç°é—®é¢˜çš„ 
- Multiple processes should not simultaneously access a shared resource, e.g. printer Ã  cooperate in granting each other temporary exclusive access
- Multiple processes need to agree on the ordering of events, e.g. message m1 from process P was sent before or after message m2 from process Q

Synchronization in Distributed Systems
Two approaches will be discussed:
- Synchronization based on actual time,
- Synchronization in which only relative ordering matters ->  no need for absolute time



# 1 Physical Time

Synchronizing algorithms: Two approaches
- global absolute time ->  actual clock time is important (e.g. real-time systems) ->  synchronize with real-world clocks
- global relative time


Clock Synchronization Algorithms
- Universal Coordinated Time (UTC)
- If one machine in the system has access to an UTC service, the goal becomes keeping all the other machines synchronized to it,
- If no machine has access to an UTC service, each machine keeps track of its own time Ã  goal is to keep all the machines together as well as possible


## 1.1 Model of the System

- Each machine i has a local clock
- Hi(t): hardware clock value (by oscillator, discontinuous)
- $C_i(t)$: software clock value (generated by operating system)
    - $C_i(t)$ = r Hi(t) + A, a tick occurs every so many quartz oscillations!
    - t is the UTC time,
    - A ist off set, start_time 
    - Clock resolution: period between updates of $C_i(t)$ ->  limit on determining order of events
    - Perfect world: $C_i(t)$ = t for all i and all t,
- $C_i(t)$: approximation of the UTC - # nsecâ€™s elapsed at time t since a reference time



# 2 Synchronization protocols

å¦‚ä½•å®ç°è¿ä¸ªæœºå™¨é—´çš„æ—¶é—´åŒæ­¥ ,  å…‹æœä¸¤ä¸ªæœºå™¨é€šè®¯çš„ latency 

![](image/Pasted%20image%2020241130224324.png)


Cristian's Algorithm
![](image/Pasted%20image%2020241130224406.png)


The Berkeley Algorithm
![](image/Pasted%20image%2020241130224452.png)












# 3 Network Time Protocol (NTP) 

- Time synchronization system for computer clocks through the Internet â€“ most widely used,
- Enables clients to be accurately synchronized to UTC despite message delays â€¦ with (worldwide) accuracy of 1-50 ms,
- Internet standard protocol
    - Version 3 (RFC-1305), simple NTP version 4 (RFC-2030)
    - Application Layer (OSI-layer 7) using UDP (port 123)
    - Clients exist for almost all platforms (Windows, Linux, etc.)
- Provides mechanisms to
    - Synchronize clocks to some reference time
    - Coordinate time distribution in a large, diverse Internet


## 3.1 Basic Features

- Based on UTC (Universal Time Coordinated)
- Independent from time zones 
    - Several institutions contribute their estimate of the current time
- Fault-tolerant
    - Selects the best of several available time sources -> leverages heterogeneous accuracy in clocks
    - Multiple candidates can be combined to minimize the accumulated error
    - Detects and avoids insane time sources
    - Survives lengthy losses of connectivity
- Highly scalable
    - Reference clock sources, sub-nodes and clients form hierarchical graph
    - Each node can exchange time information either bidirectional or unidirectional

## 3.2 Clock Strata

å±‚ï¼›[åœ°è´¨]åœ°å±‚ï¼›é˜¶å±‚

NTP uses a hierarchical system of time sources:
- Each level is termed a stratum and is assigned
- number starting with zero for the reference clock at the top,
- A server synchronized to a stratum n server runs at stratum n+1,
- The number represents the distance from the reference clock,
- Stratum is not always an indication of quality or reliability


![](image/Pasted%20image%2020241130225508.png)



- NTP client å’Œ NTP Server ä¹‹é—´å¦‚ä½•åŒæ­¥æ—¶é—´ 
    - NTP client will regularly poll one or more NTP servers
        - Exchange of several packet pairs (request, reply)
        - Containing originate resp. receive timestamp
    - To synchronize its clock, the client must compute its time offset and round-trip delay (travelling time)

![](image/Pasted%20image%2020241130230057.png)


This calculation uses the premise å‰æï¼Œå‡è®¾ that transport is symmetric (same delay in both directions) -> in principle the timeline must be an equilateral triangle
Many packet pairs and many sources are averaged over a long time ->  accuracy increases



## 3.3 NTP Operation: Server Selection

- Examine values from several peers (=servers) and look for relatively unreliable values,
- May switch the peer used primarily for sync,
- Peers with low stratum # are more favored
    - â€œcloserâ€ to primary time sources
- Also favored are peers with lowest dispersion åˆ†å¸ƒ
- May modify local clock update frequency w.r.t. observed drift rate
- Accuracy:
    - ~ 10s of milliseconds over Internet paths
    - ~ 1 millisecond on LANs

![](image/Pasted%20image%2020241130230919.png)

## 3.4 Clock Synchronization: Take-away points

- Clocks on different systems will always behave differently
    - Disagreement between machines can result in undesirable behavior
- NTP clock synchronization
    - Rely on timestamps to estimate network delays
    - 100s ğsâˆ’ms accuracy
    - Clocks never exactly synchronized
- Often inadequate for distributed systems
    - Often need to reason about the order of events
    - Might need precision on the order of ns


# 4 Logical clocks: Lamport Clocks



## 4.1 Logical Clocks


- For many purposes, ==it is sufficient that all machines agree on the same time; it does not need to be the real time,==
    - Internal consistency of the clocks matters,
    - E.g., for make tool it is sufficient to know whether input.c is older or newer than input.o
- Logical clocks proposed by Leslie Lamport in 1978
- Insight: only the events themselves matter

Basic idea:
- Disregard the precise clock time,
- Instead, capture just a â€œhappens beforeâ€ relationship between a pair of events

## 4.2 Defining â€œhappens-beforeâ€

Consider three processes: P1, P2, and P3

Notation: Event a happens before event b (a ->  b)

- Can observe event order at a single process
    - If same process and a occurs before b, then a -> b
- Can observe ordering when processes communicate
    - If c is a message receipt of b, then b -> c
- Can observe ordering transitively
    - If a ->  b and b ->  c, then a -> c
- a, d not related by ->  so concurrent, written as a || d

![](image/Pasted%20image%2020241130232903.png)


# 5 The Lamport Clock algorithm

> è¿™ä¸ªç®—æ³•çš„ä½œç”¨æ˜¯ å°† ä¸åŒ process ä¸­çš„ è‹¥å¹²ä¸ªevent , æ¯ä¸ªéƒ½ tag ä¸Š clock time  , å¹¶ä¸”ä½¿ç”¨ è¿™ä¸ªevent totally-ordered in time Horizont

- We seek a clock time C(a) for every event a on which all processes agree,
- Clock condition: If a ->  b, then C(a) < C(b)
- In addition: clock time, C, must always go forward!
- Corrections to time: adding a positive value
- Plan: tag events with clock times; use clock times to make distributed system correct

- Can totally-order events in a distributed system: thatâ€™s useful!
    - We saw an application of Lamport clocks for totally-ordered multicast
- But: while by construction, a ->  b implies C(a) < C(b),
    - The converse is not necessarily true:
        - C(a) < C(b) does not imply a ->  b (possibly, a || b)

We cannot use Lamport clock timestamps to infer causal relationships between events Ã  see vector timestamps (Tanenbaum)

## 5.1 ä¾‹å­1

![](image/Pasted%20image%2020241130233348.png)

![](image/Pasted%20image%2020241130233355.png)


![](image/Pasted%20image%2020241130233406.png)

![](image/Pasted%20image%2020241130233431.png)


![](image/Pasted%20image%2020241130233502.png)


## 5.2 ä¾‹å­2

![](image/Pasted%20image%2020241130233558.png)


## 5.3 Lamport Timestamps: Ordering all events

clock time C(a) for  event a om processes i or j 

![](image/Pasted%20image%2020241130233838.png)


