
# 1 UDP (用户数据包协议User Datagram Protocol)


-  “no frills,” “bare bones” Internet transport protocol
- “best effort” service, UDP segments may be:
    - lost
    - delivered out-of-order to app
- connectionless:
    - no handshaking between UDP sender, receiver
    - each UDP segment handled independently of others


Why is there a UDP?
- no connection establishment (which can add RTT delay)
- simple: no connection state at sender, receiver
- small header size
- no congestion control
    - UDP can blast away as fast as desired!
    - can function in the face of congestion

- Internet protocol suite supports a connectionless transport protocol called UDP (User Datagram Protocol)
- UDP provides a way for applications to send encapsulated IP datagrams without having to establish a connection

 
TCP是面向连接的，而UDP是非连接的协议。UDP没有对接受进行确认的标记和确认机制。对丢包的处理是在应用层来完成的。(or accidental arrival).

此处需要重点注意的事情是：在正常情况下，当UDP包到达一个关闭的端口时，会返回一个UDP复位包。由于UDP是非面向连接的, 因此没有任何确认信息来确认包是否正确到达目的地。因此如果你的防火墙丢弃UDP包，它会开放所有的UDP端口(?)。

由于Internet上正常情况下一些包将被丢弃，甚至某些发往已关闭端口(非防火墙的)的UDP包将不会到达目的，它们将返回一个复位UDP包。

因为这个原因，UDP端口扫描总是不精确、不可靠的。

看起来大UDP包的碎片是常见的DOS (Denial of Service)攻击的常见形式 (这里有个DOS攻击的例子，http://grc.com/dos/grcdos.htm ).

---

- The things that UDP does not do:
    - No flow control, congestion control, or retransmission => it is up to user processes to handle this
- UDP provides an interface to IP protocol with added feature of demultiplexing multiple processes using ports and optional end-to-end error detection
- But good enough to implement client-server architecture:
    - Often, client sends a short request to server and expects a short reply
    - If either request or reply is lost => client can just time out & try again
    - With UDP code is simpler + less networking overhead


---

- Netzwerkprotokoll als Alternative zu TCP
- Kein Verbindungsaufbau, keine Fluss- und Staukontrolle, Checksum optional
- Verbindungslos, nicht-zuverlässig, ungesichert, ungeschützt
- Keine Mechanismen zur Erkennung der Reihenfolge oder von verlorenen und duplizierten Paketen



# 2 UDP: User Datagram Protocol

- UDP use:
    - streaming multimedia apps (loss tolerant, rate sensitive)
    - DNS
    - SNMP
    - HTTP/3
- if reliable transfer needed over UDP (e.g., HTTP/3)
    - add needed reliability at application layer
    - add congestion control at application layer


Transport Layer Actions
UDP sender actions:
- SNMP msg is passed an application-layer message
- determines UDP segment header fields values
- creates UDP segment
- passes segment to IP


UDP receiver actions:
- receives segment from IP
- extracts application-layer message
- checks UDP checksum header value
- demultiplexes message up to application via socket

## 2.1 segment format 

![](image/Pasted%20image%2020241207125739.png)

![](image/Pasted%20image%2020241213071336.png)


# 3 UDP segment header

8-byte header has ports (TSAPs), length and checksum

![](image/Pasted%20image%2020241207130011.png)


# 4 two ports

The two ports serve to identify the endpoints within source and destination machines:
- When UDP packet arrives, its payload is handed to process (= application) attached to destination port
- Attachment occurs using BIND primitive
- Analogy: ports are mailboxes that applications can rent to receive packets
- Source port is primarily needed when a reply must be sent back to source

# 5 UDP checksum 

![](image/Pasted%20image%2020241207130024.png)


## 5.1 Internet checksum
Goal: detect errors (i.e., flipped bits) in transmitted segment

sender:
- treat contents of UDP segment (including UDP header fields and IP addresses) as sequence of 16-bit integers
- checksum: addition (one’s complement sum) of segment content
- checksum value put into UDP checksum field


receiver:
- compute checksum of received segment
- check if computed checksum equals checksum field value:
    - not equal - error detected
    - equal - no error detected. But maybe errors nonetheless? More later ….


## 5.2 Internet checksum: an example

![](image/Pasted%20image%2020241208170104.png)


Note: when adding numbers, a carryout from the most significant bit needs to be added to the result
Check out the online interactive exercises for more examples: http://gaia.cs.umass.edu/kurose_ross/interactive/


![](image/Pasted%20image%2020241208170245.png)



## 5.3 Checksum covers UDP segment and IPv4 pseudoheader

The UDP checksum is a mechanism used to detect errors in the transmission of data over a network. It is computed over the UDP segment and an IPv4 pseudoheader to ensure the integrity of both the data and critical addressing information.

- Fields that change in the network are zeroed out
- Provides an end-to-end error check => reliability
- Note: violation of protocol hierarchy since IP addresses in it belong to IP layer, not to UDP layer! => TCP uses same pseudoheader


![](image/Pasted%20image%2020241213070943.png)

---

Coverage of the UDP Checksum

The UDP checksum covers the following components:

1. **UDP Segment**:
    - **UDP Header**:
        - Source Port (16 bits)
        - Destination Port (16 bits)
        - Length (16 bits)
        - Checksum (16 bits, initially set to 0 for calculation)
    - **UDP Payload (Data)**:
        - The actual data being transmitted in the UDP datagram.
2. **IPv4 Pseudoheader**:
    - ==A pseudoheader is not part of the actual UDP packet transmitted over the network but is included in the checksum calculation to verify key parts of the IP layer.==
    - The pseudoheader includes:
        - **Source IP Address** (32 bits)
        - **Destination IP Address** (32 bits)
        - **Reserved Field** (8 bits, set to 0)
        - **Protocol** (8 bits, typically 17 for UDP)
        - **UDP Length** (16 bits, same as the length field in the UDP header)


---

Purpose of Including the IPv4 Pseudoheader

Including the pseudoheader in the checksum calculation ensures:
- **Address Validation**:
    - The checksum verifies that the UDP datagram was delivered to the correct IP addresses.
- **Protocol Verification**:
    - Confirms that the data corresponds to the UDP protocol.
- **Enhanced Integrity**:
    - Detects corruption or errors not just in the UDP segment but also in the addressing information at the IP layer.


---

(重要 )
Checksum Calculation Process
- **Concatenate the following**:
    - IPv4 pseudoheader
    - UDP header
    - UDP payload
    - Add a padding byte if the payload length is odd (to ensure 16-bit alignment).
- **Compute the sum**:
    - Treat the entire **concatenated data** as a sequence of 16-bit words.
    - Add all 16-bit words together using one’s complement arithmetic (i.e., if overflow occurs, wrap around and add it to the result).
- **One’s Complement**:
    - Take the one’s complement of the sum (invert all bits).   在 sender 方 根据 complement arithmetic  由  concatenated data 计算出来 checksum 
    - The result is the checksum value.
- **Insert the checksum**:
    - Place the computed checksum value in the checksum field of the UDP header.


Verification at the Receiver
- The receiver computes the checksum over the same components (pseudoheader, UDP header, and payload).
- It adds the computed value to the received checksum.
- If the result is **all 1s** (in one’s complement arithmetic), the datagram is considered valid. Otherwise, it is assumed to be corrupted.

在传输中 the concatenated data 可能被改变, 所以用 checksum 再去 加 concatenated data , 产生的结果 可能不再正确 


![](image/Pasted%20image%2020241208170245.png)








