



# 1 KEY AGREEMENT

两方 如何 计算 secret key shared (shared key )

常用的 key agreement 方法是 DH or ECDH 
将自己的公钥交给对方, 然后用自己的私钥+对方的公钥 产生  secret key shared (shared key )

## 1.1 KEY EXCHANGE

已经有一个 Shared Secret 加密后 传给对方

![](../../../62_Digital_Identity/image/Pasted%20image%2020241201004613.png)

- Key exchange is the process of securely transferring a secret (e.g., a random number to derive a symmetric key from or the direct symmetric key) between parties
- One party generates the secret and securely sends it to the other
- Typically one-way (secret sender -> secret receiver)
- Example: RSA key exchange
- Depends on secure transmission and encryption to prevent interception
- The sender controls the key generation


## 1.2 KEY AGREEMENT

![](../../../62_Digital_Identity/image/Pasted%20image%2020241201004813.png)


不用交换 Shared secret 了, 通过交换双方的公钥私钥 直接在自己这边产生 shared secret 

- Key agreement is a method where two parties collaboratively derive a shared secret without directly transmitting it
- Both parties contribute information to generate the shared secret
- Typically interactive (both parties exchange data to compute the secret)
- Examples: Diffi e-Hellman key agreement, Elliptic Curve Diffi e- Hellman
- Relies on mathematical problems (trapdoors) for security; no key is transmitted 
- Both parties have equal participation in key generation


## 1.3 Algorithm 去establish shared secret key


Multiple variants, but only three covered here
- Classical (Finite Set) Diffie-Hellman (DH): operates in the multiplicative group of integers modulo a large prime
- Elliptic Curve Diffie-Hellman (ECDH): uses elliptic curve groups over a fi nite fi eld
- Ephemeral Diffie-Hellman (DHE): uses temporary (ephemeral) keys for every session and may be based on DH or ECDH


### 1.3.1 FINITE SET DH

Finite Set DH is based on the Discrete Logarithm Problem

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211114528.png)


![](image/Pasted%20image%2020250215202000.png)


![](image/Pasted%20image%2020250215202011.png)

- _**Finite Set **DH****_ is based on the Discrete Logarithm Problem and operates on groups ZpZp​, where pp is a prime number, and an agreed-upon _**base number**_ g∈Zpg∈Zp​
- Both parties randomly chose secret parameters a,b∈Zpa,b∈Zp​
- Secret parameters aa and bb have associated public parameters A=gamod  pA=gamodp and B=gbmod  pB=gbmodp that are exchanged between both parties via an unsecured communication channel
- Shared secret is combined by the generated private parameter and the received public parameter, which results in the same value on both sides:

Bamod  p=(gb)amod  p=gabmod  pBamodp=(gb)amodp=gabmodp and

Abmod  p=(gb)amod  p=gabmod  pAbmodp=(gb)amodp=gabmodp

- If an attacker knows gg, gaga, and gbgb, computing gabgab is difficult without knowing aa or bb
- The shared secret is gabgab, which is passed to a _**Key Derivation Function**_ (KDF) to generate one or or more shared symmetric keys
- The prime pp must be a _**safe prime**_
- A prime pp is _**safe**_ if p−122p−1​ is also prime
- A safe prime pp guarantees that Zp∗Zp∗​ has a large cyclic subgroup of prime order p−122p−1​
- If pp is not a safe prime, Zp∗Zp∗​ can have much smaller subgroups and it would be much easier for an attacker to solve the discrete logarithm problem



### 1.3.2 ELLIPTIC CURVE DH

ECDH (Elliptic Curve Diffi e-Hellman) is based on Elliptic Curve Cryptography (ECC) and an equation of the form


![](../../../62_Digital_Identity/image/Pasted%20image%2020241211114605.png)

![](image/Pasted%20image%2020250215202024.png)


- _**ECDH**_ (_**Elliptic Curve Diffie-Hellman**_) is based on Elliptic Curve Cryptography (ECC) and an equation of the form

y2=x3+rx+sy2=x3+rx+s over a finite field FpFp​ with pp being prime

- The points (x,y)(x,y) on the curve form a group withe well-defined addition and scalar multiplication
- Both parties agree on an elliptic curve EE, its parameters (r,s,p)(r,s,p), and a generator point GG on the curve
- Both parties determine by random their private keys aa and bb and calculate the associated public keys A=aGA=aG and B=bGB=bG and exchange them 
- Shared secret SS is combined by the generated private key and the received public key, which results in the same value on both sides:

S=aB=a(bG)S=aB=a(bG) and

S=bA=b(aG)S=bA=b(aG)

- If an attacker knows GG, AA, and BB, computing SS is difficult without knowing aa or bb
- The y-coordinate of SS is used as the shared secret or input to a KDF



### 1.3.3 ANONYMOUS DH

Anonymous DH, as shown before, is vulnerable to a man-in-the-middle attack

An eavesdropper simply needs to intercept messages and pretend to be Bob towards Alice and Alice towards Bob

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211114628.png)


![](image/Pasted%20image%2020250215202038.png)

- Anonymous DH, as shown before, is vulnerable to a man-in-the-middle attack
- An eavesdropper simply needs to intercept messages and pretend to be Bob towards Alice and Alice towards Bob
- The attacker drops the messages from Alice and Bob and replaces the parameters AA and BB by its own CC and DD and sends them to Alice and Bob
- The attacker then shares  the secret gadmod  pgadmodp with Alice and gbcmod  pgbcmodp with Bob, and Alice and Bob believe they are sharing the secret with each other (for ECDH analogously)



### 1.3.4 AUTHENTICATED DH

Authenticated DH equips the two parties with both a private and a public key, thereby allowing Alice and Bob to sign their messages in order to stop the attacker from sending messages on their behalf


![](../../../62_Digital_Identity/image/Pasted%20image%2020241211114802.png)

![](image/Pasted%20image%2020250215202054.png)

- _**Authenticated DH**_ equips the two parties with both a private and a public key, thereby allowing Alice and Bob to sign their messages in order to stop the attacker from sending messages on their behalf
- Alice holds her own private key privAprivA​ and Bob's public key pubBpubB​, and vice versa for Bob, i.e., both parties need to exchange their public keys before 
- This sort of privpriv/pubpub key pair is called _**long-term key**_ because it is generated in advance and remains constant through multiple runs of the protocol
- Private keys are used on both sides to sign the messages to be sent with a signing function signsign, while the public keys are used on the other side to verify the signature
- An eavesdropper cannot pretend to be a legit party towards the other party, unless it compromises one or both private keys





## 1.4 Perfect Forward Secrecy

![](image/Pasted%20image%2020250215195708.png)


![](image/Pasted%20image%2020250215202108.png)

- What happens if an attacker records an encrypted communication in the hope of being able to compromise the long-term keys privAprivA​, privBprivB​, or both at a later time ?
    
- ==_**Perfect Forward Secrecy**_ ensures that even if a long-term private key is compromised, past communication sessions remain secure==
- ==Perfect Forward Secrecy is achieved with **_Ephemeral Diffie-Hellman_** (_**DHE**_)==
- ==For each session, Alice and Bob generate new temporary private keys aa and bb from which the shared secret gabgab is generated==
- aa and bb are used only for one key exchange and, together with gabgab, need to be deleted immediately after the session
- As aa and bb are only used for one session and deleted afterwards, they are called _**ephemeral keys**_
- As neither aa, bb, nor gab are ever transmitted, the attacker cannot record them to decrypt the message when they compromise the private keys privA and/or privB
- As aa and bb are destroyed after the session, they are not at risk of being comprised like the long-term keys






# 2 TLS 1.2  Full HANDSHAKE

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132353.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241210230240.png)



## 2.1 1-RTT HANDSHAKE  (重点 )

1. client TLS hello msg:
    1. guesses key agreement protocol, parameters
    2. indicates cipher suites it supports
2. server TLS hello msg chooses
    1. key agreement protocol, parameters
    2. cipher suite
    3. server-signed certificate
3. client:
    1. checks server certificate
    2. generates key
    3. can now make application request (e.g.., HTTPS GET)

![](image/Pasted%20image%2020250108202619.png)

### 2.1.1 Client Hello 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241209005013.png)



- A ClientHello message is sent to the server by the client to initiate the TLS handshake
- The message contains 
    - a **random number** to prevent replay attacks, 
    - ==the client's key share according to DH or ECDH== (calculated before only for this session), 
    - a list of cipher suites and signature algorithms supported by the client
- The message may contain optional fields like Server Name Indication (in case the server serves multiple domains), Application-Layer Protocol Negotiation, and a SessionId (for backward compatibility with TLS 1.2)
- The message is sent in plaintext and unsigned

----

交换什么 
4. sender 支持那些  cipher suites 
5. sender 支持哪些 key exchange groups
6. sender 支持那些 signature algorithms 
7. sender 的公钥 
8. 一个 random number to prevent replay attacks

---


两方 如何 计算 secret key shared (shared key )

常用的 key agreement 方法是 DH or ECDH 
将自己的公钥交给对方, 然后用自己的私钥+对方的公钥 产生  secret key shared (shared key )


---



### 2.1.2 ServerHello 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211111555.png)


交换什么 
9. reviver 选择那个  cipher suites, key exchange groups  用作于 之后的信息纯属 
10. sender 支持哪些 key exchange groups
11. reviver 的公钥 
12. 同样的 random number to prevent replay attacks

然后双方 根据 跟紫的 private key 和 public key 马上计算 shared key 

---

- ==The server calculates an own key share (based on DH or ECDH)== and includes it in the ServerHello message
- The message also contains a random generated by the server as well as the selected cipher suite and key exchange
- After reception of the ServerHello,==both sides calculate the key share from their own private key and the received public key==
- Note: The private keys and , the derived public keys and , the key share , and all keys derived from it must be deleted after session termination to guarantee Perfect Forward Secrecy
- The ServerHello message is sent in plaintext and unsigned



### 2.1.3 generate client and server-side handshake/application/finish keys through key derivation fucntion 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211121829.png)

- After having determined the key share S , ==both sides use a Key Derivation Function, , and other data to generate client and server-side handshake keys for encryption and decryption of further handshake messages==
- The handshake keys are ephemeral keys and need to be deleted after session termination
- All following handshake messages are encrypted from here on
- The server sends an EncryptedExtension message with further details of the session
- If the server wants to authenticate the client with a certificate, it sends a Certifi cateRequest message (optional)

#### 2.1.3.1 KEY DERIVATION FUNCTION


SIMPLISTIC VIEW

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211122010.png)

DETAILLED VIEW
![](../../../62_Digital_Identity/image/Pasted%20image%2020241211122116.png)


### 2.1.4 server sends its own certificate to client  and ServerFinished message 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211122533.png)

Certificate交换  
- The server sends its own certificate, which includes its identity and its long-term public key, and all intermediate certificates in a Certificate message

CertificateVerfy 
- The client checks the validity of the certificate ==(domain name, validity period, CA's signature, the integrity of the certificate chain, the availability of Signed Certificate Timestamps, and the revocation status with CRL or OCSP,...)==
- The server authenticates towards the client with a signature built by the current Handshake Transcript Hash signed with the long-term private key that belongs to its public key, contained in the certificate
    - Singature 的产生 是通过 Handshake Transcript Hash 去加密 一个the private key of server, 
    - 把这个 signature交给client 
- The Handshake Transcript Hash is a concatenation of all handshake message sent so far, in plaintext
- The client validates the received signature – the server is now authenticated

ServerFinished
- The server compiles a ServerFinished message, which contains a HMAC built by the current Handshake Transcript Hash signed with the server-side handshake key
    -  计算得到 HMAC , 将 这个 HMAC 交给 client, 
    - HMAC 是用来以后计算 产生 MAC 的 
    - shared key + hmac 算法 去 产生 MESSAGE AUTHENTICATION CODES (MAC)
- The client validates the received HMAC
- Note: the signature is used to authenticate the server, while the HMAC guarantees the integrity of the session and the correct derivation of the ephemeral keys

 Certificate and CertificateVerify can be omitted in some versions of the handshake


### 2.1.5 server reqeust client certificate and client send ClientFinished Message  

这个交换过程和 server sends its own certificate to client  的过程类似 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211124004.png)

- If the server has requested a client certificate, the exchange of message for sending the certificate and the signature as well as all checks are mirrored to the procedures carried out for the server certificate
- Finally, client-side and server-side ephemeral application keys (to be deleted after session termination) are determined with the Key Derivation Function, key share , and other data
- The exchange of application data, encrypted and decrypted with the application keys, starts


## 2.2 Packet Formats

![](../../../62_Digital_Identity/image/Pasted%20image%2020241210231133.png)


## 2.3 Handshake –Extensions

- In each handshake packet, many extensions fields can be included to further negotiate properties of connection
- Some properties will result in connection failure if the peer doesn't support them, others wont
- Also included in extensions are:
    - Supported crypto algorithms
    - Keying material
    - In TLS1.3 and above, the highest supported TLS version
    - This is done here instead of the version field in the ClientHellofor backwards compatibility in middleboxes

![](../../../62_Digital_Identity/image/Pasted%20image%2020241210231248.png)

## 2.4 Key exchange mode

- Client sends list of supported crypto suits/ elliptic curve groups
- Client also sends required crypto bits for each group
    - Doesn't have to be complete, can include a supported group without keying material
    - The server will then reply with HelloRetryRequest to allow the client to generate missing keying material
    - Useful for newer encryption schemes for which peer support is unknown and creating keying material is costly

# 3 TLS 1.3 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132359.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132353.png)

## 3.1 TLS 1.3 CONNECTION WITH OPENSSL

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211125643.png)

## 3.2 TLS 1.3 Handshake (重点 )


![](image/Pasted%20image%2020250215184508.png)


![](image/Pasted%20image%2020250207150448.png)


- TLS1.3 - Handshake zum Aufbau sicherer Verbindungen
- Asynchroner Austausch von Nachrichten, d.h. nach den `**ClientHello**`- und `**ServerHello**`-Nachrichten werden weitere Nachrichten gesendet sobald Daten verfügbar sind, nicht wenn vorherige Nachricht von der Gegenseite eintrifft
- Nach den `**ClientHello**`- und `**ServerHello**`-Nachrichten ist der weitere Handshake verschlüsselt
    - ClientHello 中含有 client public key and client supported cipher suite  
    - ServerHello 中含有 server  public key and server supported cipher suite  
- Perfect Forward Secrecy durch Verwendung ephemeraler Schlüssel
- Ephemerale Schlüssel und Sitzungsschlüssel werden nach Abbau der Verbindung vernichtet


----

![](image/Pasted%20image%2020250207150734.png)

- **1** und **A**: Generierung ephemeraler Schlüssel using Elliptic Curve Diffie-Hellman Ephemeral (ECDHE) 
    - 双方各自原本都有 private key 和 public key 但是不用. 
    - 基于 自己已经有的 private key 和 public, generieren jeder ein asymmetrisches ephemeraler Schlüsselpaar aus öffentlichem und privatem Schlüssel
- **2** und **B**: Austausch eigenen ephemeraler public Schlüssel an anderen Seite und Einigung auf Cipher Suite
- **3** und **C**: Berechnung eines gemeinsamen Sitzungsschlüssels (symmetric session key) aus empfangenem öffentlichen Schlüssel der Gegenseite und eigenem privaten Schlüssel
- Ephemerale Schlüssel (the generierte jeder ein asymmetrisches ephemeraler Schlüsselpaar aus öffentlichem und privatem Schlüssel) und Sitzungsschlüssel  (sysmetrische session key) werden nach Abbau der Verbindung vernichtet 会被 抛弃掉
-  sysmetrische session key 的用处 
    - generate client and server-side handshake/application/finish keys through key derivation function  and sysmetrische ephermal session key( 也叫做 shared key)
    -  server-side handshake keys 用于 加密 the communication during the handshake phase ,  ServerCertificate, ServerCertificateVerify/ServerSignature,   ServerFinish
    - Client-side handshake keys 用于 加密 the communication during the handshake phase ,  ClientCertificate, ClientCertificateVerify/ClientSignature,   ClientFinish
    - application key 用于加密 tls 握手之后 的 普通的 application data 的传输
    - handshake keys   application key  都是通过 key derivation function  and sysmetrische session key 生成的, 但是两者的值不一样



- **D**: Optionale Anfrage eines Client-Zertifikats
- **E**: Übersendung Server-Zertifikat mit permanentem öffentlichem Schlüssel  
    - Server-Zertifikat 中本身就含有 server permanentem öffentlichem Schlüssel 
- **4**: Überprüfung des Server-Zertifikats
    - The client checks the validity of the certificate ==(domain name, validity period, CA's signature, the integrity of the certificate chain, the availability of Signed Certificate Timestamps, and the revocation status with CRL or OCSP,...)==
    - 重要的是 获取 server permanentem öffentlichem Schlüssel . 他讲用于 后边  Überprüfen der Server-Signatur
- **F**: Generierung einer Server-Signatur mit dem permanenten privaten Schlüssel des Server
- **G**: Übersendung der Signatur

---

![](image/Pasted%20image%2020250207151012.png)


- **5**: Authentifizierung des Server durch Überprüfen der Server-Signatur
    - 将 receiver 处得到的 signure 通过 server public key 解密 得到 Digest, 然后 和 clinet 自己通过 hash funktion 计算出来的 digest 进行对比 
- **H**: Abschluss des Handshake durch den Server

- **6**: Übersendung Client-Zertifikat mit permanentem öffentlichem Schlüssel des Client
- **I**: Überprüfung des Client-Zertifikats
- **7**: Generierung einer Client-Signatur mit dem permanenten privaten Schlüssel des Client
- **8**: Übersendung der Client-Signatur
- **J**: Authentifizierung des Client durch Überprüfen der Client-Signatur
- **9**: Abschluss des Handshake durch den Client


- **11** und **L**: Austausch von Anwendungsdaten (HTTPS Request/Response)
    - Anwendungsdaten 的加密 不是直接用  certificate 中的 public key.  而是 用 application key (是 通过  key derivation function  and sysmetrische ephermal session key ) 和  HAMC (去计算 mac). 详细的见 RECORD PROTOCOL 那一部分 在 60_02_01_02_TLS_TRANSPORT_LAYER_SECURITY 章节中 



## 3.3 TLS1.3 通过 pre-shared key 和 0-RTT 优化 TLS 1.2的 handshake process 



### 3.3.1 Abbreviated handshake WITH pre-shared key(PSK) RESUMPTION

实现快速连接 

- ==It reduces the overhead of the full handshake by skipping steps like certificate validation and key exchange, leveraging a previously established shared secret.==
- This is commonly used in scenarios like session resumption to improve performance and reduce latency while maintaining security.
- ==使用从前 session 中 产生的 shared secret  key ==

---

- To enable faster reconnection, client and server do not always go through the full handshake, but perform an abbreviated handshake using using pre-shared key (PSK) resumption
- A PSK is a cryptographic key shared between client and server after the previous handshake
- Two handshake types
    - PSK-Only Handshake: The PSK is the sole basis for authentication, no certificates are used and DH is not applied
    - PSK with DHE: Combines PSK with Ephemeral Diffi e-Hellman key agreement to provide forward secrecy


- Can be used to reduce delay by allowing 0-RTT data
    - E.g., Client can send (early) application data with ClientHello
- Can be either issued with NewSessionTicket messages for future connections or provisioned out of band
    - Useful if multiple connections between same server and client are expected
- E.g., multiple HTTP connections for websites etc.
    - Tickets have a certain lifetime as well so they can be used for future sessions

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211125739.png)



![](../../../62_Digital_Identity/image/Pasted%20image%2020241210231918.png)


#### 3.3.1.1 **How PSK Resumption Works**

Pre-Shared Key (PSK) Setup
- A shared secret is established during a previous session handshake.
- This secret is derived from the key exchange (e.g., Diffie-Hellman) and is securely stored as a session ticket or session ID.

Client Initiates Resumption
- The client sends a **ClientHello** message, including the session ticket or PSK identity.
- The PSK identity indicates which shared secret the client wants to use.

Server Validates and Agrees
- If the server recognizes the PSK identity and validates it, it responds with a **ServerHello**, confirming the use of the shared PSK.
- Both client and server use the PSK to derive new session keys for encryption.

Key Derivation
- New session keys are derived from the shared PSK and other handshake parameters (e.g., random values from the ClientHello and ServerHello).
- These keys are used for securing the resumed session.

Finished Messages
- Both client and server exchange "Finished" messages to confirm the handshake.
- Secure communication resumes immediately without requiring a full handshake.

#### 3.3.1.2 Message Flow: Abbreviated PSK Handshake

ClientHello:
    Includes the PSK identity and supported cipher suites.
ServerHello:
    Confirms the use of the PSK and selects the cipher suite.
Key Derivation:
    Both sides derive session keys using the PSK and exchanged random values.
Finished:
    Client and server verify the handshake using the derived keys.
Secure Data Transmission:
    Encrypted communication resumes using the new session keys.


### 3.3.2 0-RTT HANDSHAKE



![](image/Pasted%20image%2020250108202721.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211131015.png)

- A 0-RTT (Zero Round-Trip Time) handshake allows a client to send data immediately after the ClientHello message without waiting for the server's response
- It reduces latency, making connections faster, especially for applications requiring low delays, such as web browsing, APIs, and real-time communication
- ==The 0-RTT handshake relies on a PSK established during a prior connection==
- Application-data is encrypted with a PSK-derived key
- Advantages: reduced latency and efficiency
- Disadvantages: Risk of replay attacks and no forward secrecy

- initial hello message contains encrypted application data!
    - “resuming” earlier connection between client and server
    - application data encrypted using “resumption master secret” from earlier connection
- vulnerable to replay attacks!
    - maybe OK for get HTTP GET or client requests not modifying server state
## 3.4 TLS 1.3 CIPHER SUITES

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211131415.png)

A Cipher Suite Contains
- protokoll 
- key exchange approach 
- symmetrkic and aystmmetric Encryption Algorithms
- algorithmus of hashing functoin 
- ... 


- A cipher suite is a standardized set of algorithms used to secure communications in protocols like TLS
- “cipher suite”: algorithms that can be used for key generation, encryption, MAC, digital signature
- ==A cipher suite for TLS 1.2 defines==
    - the key agreement algorithm (RSA, DH, ECDHE), 
    - the authentication algorithm (RSA, ECDSA), 
    - the encryption algorithm (AES, ChaCha20, RC4) as well as its encryption strength and mode, 
    - the Message Authentication Code algorithm
- In TLS 1.3 the cipher suites are simplified and ==only specify the encryption algorithm and hash function==
- TLS 1.3 only uses DHE and PSK as key agreement algorithms, while the required authentication algorithms depend on the used certificates

- TLS: 1.3 (2018): more limited cipher suite choice than TLS 1.2 (2008)
    - only 5 choices, rather than 37 choices
    - requires Diffie-Hellman (DH) for key exchange, rather than DH or RSA
    - combined encryption and authentication algorithm (“authenticated encryption”) for data rather than serial encryption, authentication
        - 4 based on AES\
    - HMAC uses SHA (256 or 284) cryptographic hash function

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211131948.png)


# 4 不同 TLS 1.2 vs 1.3 vs Quic 



![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132037.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132353.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132359.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132153.png)


---

QUIC: 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132221.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132413.png)

