



# 1 KEY AGREEMENT

两方 如何 计算 secret key shared (shared key )

常用的 key agreement 方法是 DH or ECDH 
将自己的公钥交给对方, 然后用自己的私钥+对方的公钥 产生  secret key shared (shared key )

## 1.1 KEY EXCHANGE

已经有一个 Shared Secret 加密后 传给对方

![](../../../62_Digital_Identity/image/Pasted%20image%2020241201004613.png)

- Key exchange is the process of securely transferring a secret (e.g., a random number to derive a symmetric key from or the direct symmetric key) between parties
- One party generates the secret and securely sends it to the other
- Typically one-way (secret sender -> secret receiver)
- Example: RSA key exchange
- Depends on secure transmission and encryption to prevent interception
- The sender controls the key generation


## 1.2 KEY AGREEMENT

![](../../../62_Digital_Identity/image/Pasted%20image%2020241201004813.png)


不用交换 Shared secret 了, 通过交换双方的公钥私钥 直接在自己这边产生 shared secret 

- Key agreement is a method where two parties collaboratively derive a shared secret without directly transmitting it
- Both parties contribute information to generate the shared secret
- Typically interactive (both parties exchange data to compute the secret)
- Examples: Diffi e-Hellman key agreement, Elliptic Curve Diffi e- Hellman
- Relies on mathematical problems (trapdoors) for security; no key is transmitted 
- Both parties have equal participation in key generation


## 1.3 Algorithm 去establish shared secret key


Multiple variants, but only three covered here
- Classical (Finite Set) Diffie-Hellman (DH): operates in the multiplicative group of integers modulo a large prime
- Elliptic Curve Diffie-Hellman (ECDH): uses elliptic curve groups over a fi nite fi eld
- Ephemeral Diffie-Hellman (DHE): uses temporary (ephemeral) keys for every session and may be based on DH or ECDH


### 1.3.1 FINITE SET DH

Finite Set DH is based on the Discrete Logarithm Problem

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211114528.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211114536.png)


![](../../../62_Digital_Identity/image/Pasted%20image%2020241201010036.png)


### 1.3.2 ELLIPTIC CURVE DH

ECDH (Elliptic Curve Diffi e-Hellman) is based on Elliptic Curve Cryptography (ECC) and an equation of the form


![](../../../62_Digital_Identity/image/Pasted%20image%2020241211114605.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211114615.png)



### 1.3.3 ANONYMOUS DH

Anonymous DH, as shown before, is vulnerable to a man-in-the-middle attack

An eavesdropper simply needs to intercept messages and pretend to be Bob towards Alice and Alice towards Bob

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211114628.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211114644.png)

### 1.3.4 AUTHENTICATED DH

Authenticated DH equips the two parties with both a private and a public key, thereby allowing Alice and Bob to sign their messages in order to stop the attacker from sending messages on their behalf


![](../../../62_Digital_Identity/image/Pasted%20image%2020241211114802.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211114947.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211120608.png)


# 2 TLS 1.2  HANDSHAKE

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132353.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241210230240.png)



## 2.1 1-RTT HANDSHAKE

1. client TLS hello msg:
    1. guesses key agreement protocol, parameters
    2. indicates cipher suites it supports
2. server TLS hello msg chooses
    1. key agreement protocol, parameters
    2. cipher suite
    3. server-signed certificate
3. client:
    1. checks server certificate
    2. generates key
    3. can now make application request (e.g.., HTTPS GET)

![](image/Pasted%20image%2020250108202619.png)

### 2.1.1 Client Hello 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241209005013.png)


交换什么 
4. sender 支持那些  cipher suites 
5. sender 支持哪些 key exchange groups
6. sender 支持那些 signature algorithms 
7. sender 的公钥 
8. 一个 random number to prevent replay attacks

---


两方 如何 计算 secret key shared (shared key )

常用的 key agreement 方法是 DH or ECDH 
将自己的公钥交给对方, 然后用自己的私钥+对方的公钥 产生  secret key shared (shared key )


---


- A ClientHello message is sent to the server by the client to initiate the TLS handshake
- The message contains 
    - a **random number** to prevent replay attacks, 
    - ==the client's key share according to DH or ECDH== (calculated before only for this session), 
    - a list of cipher suites and signature algorithms supported by the client
- The message may contain optional fields like Server Name Indication (in case the server serves multiple domains), Application-Layer Protocol Negotiation, and a SessionId (for backward compatibility with TLS 1.2)
- The message is sent in plaintext and unsigned


### 2.1.2 ServerHello 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211111555.png)


交换什么 
9. reviver 选择那个  cipher suites, key exchange groups  用作于 之后的信息纯属 
10. sender 支持哪些 key exchange groups
11. reviver 的公钥 
12. 同样的 random number to prevent replay attacks

然后双方 根据 跟紫的 private key 和 public key 马上计算 shared key 

---

- ==The server calculates an own key share (based on DH or ECDH)== and includes it in the ServerHello message
- The message also contains a random generated by the server as well as the selected cipher suite and key exchange
- After reception of the ServerHello,==both sides calculate the key share from their own private key and the received public key==
- Note: The private keys and , the derived public keys and , the key share , and all keys derived from it must be deleted after session termination to guarantee Perfect Forward Secrecy
- The ServerHello message is sent in plaintext and unsigned



### 2.1.3 generate client and server-side handshake/application/finish keys through key derivation fucntion 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211121829.png)

- After having determined the key share S , ==both sides use a Key Derivation Function, , and other data to generate client and server-side handshake keys for encryption and decryption of further handshake messages==
- The handshake keys are ephemeral keys and need to be deleted after session termination
- All following handshake messages are encrypted from here on
- The server sends an EncryptedExtension message with further details of the session
- If the server wants to authenticate the client with a certificate, it sends a Certifi cateRequest message (optional)

#### 2.1.3.1 KEY DERIVATION FUNCTION


SIMPLISTIC VIEW

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211122010.png)

DETAILLED VIEW
![](../../../62_Digital_Identity/image/Pasted%20image%2020241211122116.png)


### 2.1.4 server sends its own certificate to client  and ServerFinished message 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211122533.png)

Certificate交换  
- The server sends its own certificate, which includes its identity and its long-term public key, and all intermediate certificates in a Certificate message

CertificateVerfy 
- The client checks the validity of the certificate ==(domain name, validity period, CA's signature, the integrity of the certificate chain, the availability of Signed Certificate Timestamps, and the revocation status with CRL or OCSP,...)==
- The server authenticates towards the client with a signature built by the current Handshake Transcript Hash signed with the long-term private key that belongs to its public key, contained in the certificate
    - Singature 的产生 是通过 Handshake Transcript Hash 去加密 一个the private key of server, 
    - 把这个 signature交给client 
- The Handshake Transcript Hash is a concatenation of all handshake message sent so far, in plaintext
- The client validates the received signature – the server is now authenticated

ServerFinished
- The server compiles a ServerFinished message, which contains a HMAC built by the current Handshake Transcript Hash signed with the server-side handshake key
    -  计算得到 HMAC , 将 这个 HMAC 交给 client, 
    - HMAC 是用来以后计算 产生 MAC 的 
    - shared key + hmac 算法 去 产生 MESSAGE AUTHENTICATION CODES (MAC)
- The client validates the received HMAC
- Note: the signature is used to authenticate the server, while the HMAC guarantees the integrity of the session and the correct derivation of the ephemeral keys

 Certificate and CertificateVerify can be omitted in some versions of the handshake


### 2.1.5 server rqeust client certificate and client send ClientFinished Message  

这个交换过程和 server sends its own certificate to client  的过程类似 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211124004.png)

- If the server has requested a client certificate, the exchange of message for sending the certificate and the signature as well as all checks are mirrored to the procedures carried out for the server certificate
- Finally, client-side and server-side ephemeral application keys (to be deleted after session termination) are determined with the Key Derivation Function, key share , and other data
- The exchange of application data, encrypted and decrypted with the application keys, starts


## 2.2 Packet Formats

![](../../../62_Digital_Identity/image/Pasted%20image%2020241210231133.png)


## 2.3 Handshake –Extensions

- In each handshake packet, many extensions fields can be included to further negotiate properties of connection
- Some properties will result in connection failure if the peer doesn't support them, others wont
- Also included in extensions are:
    - Supported crypto algorithms
    - Keying material
    - In TLS1.3 and above, the highest supported TLS version
    - This is done here instead of the version field in the ClientHellofor backwards compatibility in middleboxes

![](../../../62_Digital_Identity/image/Pasted%20image%2020241210231248.png)

## 2.4 Key exchange mode

- Client sends list of supported crypto suits/ elliptic curve groups
- Client also sends required crypto bits for each group
    - Doesn't have to be complete, can include a supported group without keying material
    - The server will then reply with HelloRetryRequest to allow the client to generate missing keying material
    - Useful for newer encryption schemes for which peer support is unknown and creating keying material is costly

# 3 TLS 1.3 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132359.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132353.png)

## 3.1 TLS 1.3 CONNECTION WITH OPENSSL

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211125643.png)


## 3.2 TLS 1.3 Handshake (重点 )

![](image/Pasted%20image%2020250207150448.png)


- TLS1.3 - Handshake zum Aufbau sicherer Verbindungen
- Asynchroner Austausch von Nachrichten, d.h. nach den `**ClientHello**`- und `**ServerHello**`-Nachrichten werden weitere Nachrichten gesendet sobald Daten verfügbar sind, nicht wenn vorherige Nachricht von der Gegenseite eintrifft
- Nach den `**ClientHello**`- und `**ServerHello**`-Nachrichten ist der weitere Handshake verschlüsselt
- Perfect Forward Secrecy durch Verwendung ephemeraler Schlüssel
- Ephemerale Schlüssel und Sitzungsschlüssel werden nach Abbau der Verbindung vernichtet


----

![](image/Pasted%20image%2020250207150734.png)

- **1** und **A**: Generierung ephemeraler Schlüssel
- **2** und **B**: Austausch ephemeraler Schlüssel und Einigung auf Cipher Suite
- **3** und **C**: Berechnung eines gemeinsamen Sitzungsschlüssels aus empfangenem öffentlichen Schlüssel der Gegenseite und eigenem privaten Schlüssel
- **D**: Optionale Anfrage eines Client-Zertifikats
- **E**: Übersendung Server-Zertifikat mit permanentem öffentlichem Schlüssel
- **4**: Überprüfung des Server-Zertifikats
- **F**: Generierung einer Server-Signatur mit dem permanenten privaten Schlüssel des Server
- **G**: Übersendung der Signatur

---

![](image/Pasted%20image%2020250207151012.png)


- **5**: Authentifizierung des Server durch Überprüfen der Server-Signatur
- **H**: Abschluss des Handshake durch den Server
- **6**: Übersendung Client-Zertifikat mit permanentem öffentlichem Schlüssel des Client
- **I**: Überprüfung des Client-Zertifikats
- **7**: Generierung einer Client-Signatur mit dem permanenten privaten Schlüssel des Client
- **8**: Übersendung der Client-Signatur
- **J**: Authentifizierung des Client durch Überprüfen der Client-Signatur
- **9**: Abschluss des Handshake durch den Client
- **11** und **L**: Austausch von Anwendungsdaten (HTTPS Request/Response)



## 3.3 TLS1.3 通过 pre-shared key 和 0-RTT 优化 TLS 1.2的 handshake process 



### 3.3.1 Abbreviated handshake WITH pre-shared key(PSK) RESUMPTION

实现快速连接 

- ==It reduces the overhead of the full handshake by skipping steps like certificate validation and key exchange, leveraging a previously established shared secret.==
- This is commonly used in scenarios like session resumption to improve performance and reduce latency while maintaining security.
- 使用从前 session 中 产生的 shared secret  key 

---

- To enable faster reconnection, client and server do not always go through the full handshake, but perform an abbreviated handshake using using pre-shared key (PSK) resumption
- A PSK is a cryptographic key shared between client and server after the previous handshake
- Two handshake types
    - PSK-Only Handshake: The PSK is the sole basis for authentication, no certificates are used and DH is not applied
    - PSK with DHE: Combines PSK with Ephemeral Diffi e-Hellman key agreement to provide forward secrecy


- Can be used to reduce delay by allowing 0-RTT data
    - E.g., Client can send (early) application data with ClientHello
- Can be either issued with NewSessionTicket messages for future connections or provisioned out of band
    - Useful if multiple connections between same server and client are expected
- E.g., multiple HTTP connections for websites etc.
    - Tickets have a certain lifetime as well so they can be used for future sessions

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211125739.png)



![](../../../62_Digital_Identity/image/Pasted%20image%2020241210231918.png)


#### 3.3.1.1 **How PSK Resumption Works**

Pre-Shared Key (PSK) Setup
- A shared secret is established during a previous session handshake.
- This secret is derived from the key exchange (e.g., Diffie-Hellman) and is securely stored as a session ticket or session ID.

Client Initiates Resumption
- The client sends a **ClientHello** message, including the session ticket or PSK identity.
- The PSK identity indicates which shared secret the client wants to use.

Server Validates and Agrees
- If the server recognizes the PSK identity and validates it, it responds with a **ServerHello**, confirming the use of the shared PSK.
- Both client and server use the PSK to derive new session keys for encryption.

Key Derivation
- New session keys are derived from the shared PSK and other handshake parameters (e.g., random values from the ClientHello and ServerHello).
- These keys are used for securing the resumed session.

Finished Messages
- Both client and server exchange "Finished" messages to confirm the handshake.
- Secure communication resumes immediately without requiring a full handshake.

#### 3.3.1.2 Message Flow: Abbreviated PSK Handshake

ClientHello:
    Includes the PSK identity and supported cipher suites.
ServerHello:
    Confirms the use of the PSK and selects the cipher suite.
Key Derivation:
    Both sides derive session keys using the PSK and exchanged random values.
Finished:
    Client and server verify the handshake using the derived keys.
Secure Data Transmission:
    Encrypted communication resumes using the new session keys.


### 3.3.2 0-RTT HANDSHAKE

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211131015.png)

![](image/Pasted%20image%2020250108202721.png)

- A 0-RTT (Zero Round-Trip Time) handshake allows a client to send data immediately after the ClientHello message without waiting for the server's response
- It reduces latency, making connections faster, especially for applications requiring low delays, such as web browsing, APIs, and real-time communication
- ==The 0-RTT handshake relies on a PSK established during a prior connection==
- Application-data is encrypted with a PSK-derived key
- Advantages: reduced latency and efficiency
- Disadvantages: Risk of replay attacks and no forward secrecy

- initial hello message contains encrypted application data!
    - “resuming” earlier connection between client and server
    - application data encrypted using “resumption master secret” from earlier connection
- vulnerable to replay attacks!
    - maybe OK for get HTTP GET or client requests not modifying server state
## 3.4 TLS 1.3 CIPHER SUITES

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211131415.png)


- A cipher suite is a standardized set of algorithms used to secure communications in protocols like TLS
- “cipher suite”: algorithms that can be used for key generation, encryption, MAC, digital signature
- ==A cipher suite for TLS 1.2 defines==
    - the key agreement algorithm (RSA, DH, ECDHE), 
    - the authentication algorithm (RSA, ECDSA), 
    - the encryption algorithm (AES, ChaCha20, RC4) as well as its encryption strength and mode, 
    - the Message Authentication Code algorithm
- In TLS 1.3 the cipher suites are simplified and ==only specify the encryption algorithm and hash function==
- TLS 1.3 only uses DHE and PSK as key agreement algorithms, while the required authentication algorithms depend on the used certificates

- TLS: 1.3 (2018): more limited cipher suite choice than TLS 1.2 (2008)
    - only 5 choices, rather than 37 choices
    - requires Diffie-Hellman (DH) for key exchange, rather than DH or RSA
    - combined encryption and authentication algorithm (“authenticated encryption”) for data rather than serial encryption, authentication
        - 4 based on AES\
    - HMAC uses SHA (256 or 284) cryptographic hash function

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211131948.png)


# 4 不同 TLS 1.2 vs 1.3 vs Quic 



![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132037.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132353.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132359.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132153.png)


---

QUIC: 

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132221.png)

![](../../../62_Digital_Identity/image/Pasted%20image%2020241211132413.png)

