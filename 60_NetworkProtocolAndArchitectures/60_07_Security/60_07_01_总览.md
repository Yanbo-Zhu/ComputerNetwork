
What is network security?
Principles of cryptography
Authentication, message integrity
Securing e-mail
Securing TCP connections: TLS
Network layer security: IPsec
Security in wireless and mobile networks
Operational security: firewalls and IDS

Chapter goals:
- understand principles of network security:
    - cryptography and its many uses beyond “confidentiality”
    - authentication
    - message integrity
- security in practice:
    - firewalls and intrusion detection systems
    - security in application, transport, network, link layers

# 1 network security

- confidentiality: only sender, intended receiver should “understand” message contents
    - sender encrypts message
    - receiver decrypts message
- authentication: sender, receiver want to confirm identity of each other
- message integrity: sender, receiver want to ensure message not altered (in transit, or afterwards) without detection
- access and availability: services must be accessible and available to users


例子 Friends and enemies: Alice, Bob, Trudy
well-known in network security world
Bob, Alice (lovers!) want to communicate “securely”
Trudy (intruder) may intercept, delete, add messages

![](image/Pasted%20image%2020250106172342.png)

Who might Bob and Alice be?
- … well, real-life Bobs and Alices!
- Web browser/server for electronic transactions (e.g., on-line purchases)
- on-line banking client/server
- DNS servers
- BGP routers exchanging routing table updates
- other examples?

---

There are bad guys (and girls) out there!
Q: What can a “bad guy” do?
A: A lot! (recall section 1.6)
- eavesdrop: intercept messages
- actively insert messages into connection
- impersonation: can fake (spoof) source address in packet (or any field in packet)
- hijacking: “take over” ongoing connection by removing sender or receiver, inserting himself in place
- denial of service: prevent service from being used by others (e.g., by overloading resources)


# 2 Principles of cryptography

![](image/Pasted%20image%2020250106172644.png)

Breaking an encryption scheme

- cipher-text only attack: Trudy has ciphertext she can analyze
- two approaches:
    - brute force: search through all keys
    - statistical analysis
- known-plaintext attack: Trudy has plaintext corresponding to ciphertext
    - e.g., in monoalphabetic cipher, Trudy determines pairings for a,l,i,c,e,b,o,
- chosen-plaintext attack: Trudy can get ciphertext for chosen plaintext


## 2.1 Symmetric key cryptography


Symmetric key cryptography
- Bob and Alice share same (symmetric) key: K
    - e.g., key is knowing substitution pattern in mono alphabetic substitution cipher

![](image/Pasted%20image%2020250106172946.png)


Simple encryption scheme
- substitution cipher: substituting one thing for another
    - monoalphabetic cipher: substitute one letter for another
- ![](image/Pasted%20image%2020250106173031.png)

A more sophisticated encryption approach
- n substitution ciphers, M1,M2,…,Mn
- cycling pattern:
    - e.g., n=4: M1,M3,M4,M3,M2; M1,M3,M4,M3,M2; ..
- for each new plaintext symbol, use subsequent substitution pattern in cyclic pattern
    - dog: d from M1, o from M3, g from M4
- Encryption key: n substitution ciphers, and cyclic pattern
    - key need not be just n-bit pattern




Symmetric key crypto: DES
DES: Data Encryption Standard
- US encryption standard [NIST 1993]
- 56-bit symmetric key, 64-bit plaintext input
- block cipher with cipher block chaining
- how secure is DES?
    - DES Challenge: 56-bit-key-encrypted phrase decrypted (brute force) in less than a day
    - no known good analytic attack
- making DES more secure:
    - 3DES: encrypt 3 times with 3 different keys



AES: Advanced Encryption Standard
- Security: 8- 15
- symmetric-key NIST standard, replaced DES (Nov 2001)
- processes data in 128 bit blocks
- 128, 192, or 256 bit keys
- brute force decryption (try each key) taking 1 sec on DES, takes 149 trillion years for AES


## 2.2 Public Key Cryptography

- symmetric key crypto:
    - requires sender, receiver know shared secret key
    - Q: how to agree on key in first place (particularly if never “met”)?
- public key crypto
    - radically different approach [Diffie-Hellman76, RSA78]
    - sender, receiver do not share secret key
    - public encryption key known to all
    - private decryption key known only to receiver


![](image/Pasted%20image%2020250106173628.png)

Public key encryption algorithms
![](image/Pasted%20image%2020250106173708.png)


Prerequisite: modular arithmetic
- x mod n = remainder of x when divide by n
- facts:
    - [(a mod n) + (b mod n)] mod n = (a+b) mod n
    - [(a mod n) - (b mod n)] mod n = (a-b) mod n
    - [(a mod n) * (b mod n)] mod n = (a*b) mod n
- thus
    - (a mod n)d mod n = ad mod n
- example: x=14, n=10, d=2: 
    - ( (x mod n)^d mod n) = 4^2 mod 10 = 6 
    - x^d = 14^2 = 196, x^d mod 10 = 6

## 2.3 RSA

- message: just a bit pattern
- bit pattern can be uniquely represented by an integer number
- thus, encrypting a message is equivalent to encrypting a number

example:
- m= 10010001. This message is uniquely represented by the decimal number 145.
- to encrypt m, we encrypt the corresponding number, which gives a new number (the ciphertext).

Creating public/private key pair
![](image/Pasted%20image%2020250106174042.png)


encryption, decryption
![](image/Pasted%20image%2020250106174055.png)


RSA example
![](image/Pasted%20image%2020250106174110.png)

![](image/Pasted%20image%2020250106174300.png)

![](image/Pasted%20image%2020250106174309.png)


![](image/Pasted%20image%2020250106174317.png)

Why is RSA secure?
suppose you know Bob’s public key (n,e). How hard is it to determine d?
essentially need to find factors of n without knowing the two factors p and q
fact: factoring a big number is hard


RSA in practice: session keys
exponentiation in RSA is computationally intensive
DES is at least 100 times faster than RSA
use public key crypto to establish secure connection, then establish second key – symmetric session key – for encrypting data

session key, KS
Bob and Alice use RSA to exchange a symmetric session key KS
once both have KS, they use symmetric key cryptography



# 3 Authentication, message integrity

![](image/Pasted%20image%2020250106174719.png)

![](image/Pasted%20image%2020250106174727.png)


## 3.1 Digital signatures

用 private key 去加密 一个 message, 这种形式 就是  Digital signature 的一种 

cryptographic technique analogous to hand-written signatures:
▪ sender (Bob) digitally signs document: he is document owner/creator.
▪ verifiable, nonforgeable: recipient (Alice) can prove to someone that Bob, and no one else (including Alice), must have signed document
▪ simple digital signature for message m:
    • Bob signs m by encrypting with his private key KB, creating “signed” message, KB-(m)
![](image/Pasted%20image%2020250106175356.png)


- suppose Alice receives msg m, with signature: m, KB(m)
- Alice verifies m signed by Bob by applying Bob’s public key KB to KB(m) then checks KB(KB(m) ) = m.
- If KB(KB(m) ) = m, whoever signed m must have used Bob’s private key

Alice thus verifies that:
- Bob signed m
- no one else signed m
- Bob signed m and not m’
non-repudiation:
- Alice can take m, and signature KB(m) to court and prove that Bob signed m


## 3.2 Message digests

computationally expensive to public-key-encrypt long messages
goal: fixed-length, easy- to-compute digital “fingerprint”
- apply hash function H to m, get fixed size message digest, H(m)

Hash function properties:
- many-to-1
- produces fixed-size msg digest (fingerprint)
- given message digest x, computationally infeasible to find m such that x = H(m)